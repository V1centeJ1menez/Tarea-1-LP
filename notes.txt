··············· ABSTRACT ··············· 

Definir patrones
Generar tokens (tokenizer, lexer)
Construir parser (estructura sintactica)
construir ast ()

··············· GRAMATICA ··············· 

EBNF General
digito ::= ’1’ | ’2’ | ’3’ | ’4’ | ’5’ | ’6’ | ’7’ | ’8’ | ’9’
digito_o_cero ::= digito | ’0’
entero ::= (digito {digito_o_cero}) | ’0’
booleano ::= ’True’ | ’False’
string ::= ’#’ {A-Z | a-z | digito_o_cero | ’ ’} ’#’
tipo ::= ’int’ | ’bool’ | ’string’
oper_un ::= ’ASIG’
oper_bin ::= ’+’ | ’*’ | ’>’ | ’==’
operando ::= variable | entero | booleano | string
linea ::= declaracion | procesar | condicional | mostrar
variable ::= ’$_’ (A-Z) {A_Z | a-z}
declaracion ::= ’DEFINE’ variable
procesar ::= ’DP’ variable ((oper_un operando) | (oper_bin operando operando))
condicional ::= ’if(’ variable ’) {’ {linea} ’} else {’ {linea} ’}’
mostrar ::= ’MOSTRAR(’ variable ’)’

··············· CONSIDERACIONES ··············· 

- Se destaca que la cantidad de espacio entre palabras es indeterminada.
- No van a ver lineas vacias.
- Cada linea de codigo debe terminar con un salto de linea.
- La identacion no afecta la ejecucin del programa.
- La cantidad de condicionales anidadas es hasta 3 veces.
- Las operaciones pueden hacerse solo una a la vez y tienen una variable de destinto y uno o dos operandos.
-Todas las funciones deben ir comentadas con el siguiente formato:

’’’
***
Parametro 1 : Tipo
Parametro 2 : Tipo
...
***
Tipo de Retorno o None
***
Breve descripcion de la funcion y el retorno
’’’

- Arbol sintactico da el orden de ejecución del programa. Dada por la gamatica libre de contexto no ambiguas.
- Resolucion de ambiguedades con precedencia y asociatividad.


··············· ERRORES ··············· 

- Mal Sintaxis: La linea (N) no está bien escrita.
- Variable No Definida: La variable de nombre (nombre) no ha sido definida o no se le ha asignad valor en la línea (N).
- Tipo Incompatible: La operación DP o condicional en la línea (N) es incompatible al tipo de dato.
- Varianle Ya Definida: La variable de nombre (nombre) ya se encuentra definida.

··············· AYUDANTIA ··············· 

- Latarea 1 se tiene que crear un interprete en lenguaje Python. Lenguaje ya conocido antes.
  pero hay algunas cosas que no se habían enseñado. Por ejemplo: manejo de excepciones, y la libreria
  RegEx


  EBNF General
digito ::= ’1’ | ’2’ | ’3’ | ’4’ | ’5’ | ’6’ | ’7’ | ’8’ | ’9’
digito_o_cero ::= digito | ’0’
entero ::= (digito {digito_o_cero}) | ’0’
booleano ::= ’True’ | ’False’
string ::= ’#’ {A-Z | a-z | digito_o_cero | ’ ’} ’#’
tipo ::= ’int’ | ’bool’ | ’string’
oper_un ::= ’ASIG’
oper_bin ::= ’+’ | ’*’ | ’>’ | ’==’
operando ::= variable | entero | booleano | string
linea ::= declaracion | procesar | condicional | mostrar
variable ::= ’$_’ (A-Z) {A_Z | a-z}
declaracion ::= ’DEFINE’ variable
procesar ::= ’DP’ variable ((oper_un operando) | (oper_bin operando operando))
condicional ::= ’if(’ variable ’) {’ {linea} ’} else {’ {linea} ’}’
mostrar ::= ’MOSTRAR(’ variable ’)’


vamos operacion por operacion: 

1) para declarar una variable, se usa la palabra clave DEFINE, ejemplos:
      DEFINE $_var

las siguiente instrucciones solo pueden hacer una operacion a la vez, tienen una variable de destino y uno o dos operandos que pueden ser una variable o una constante de tipo entero, booleano o string:

2) para la asignacion, está dada or la palabra ASIG, es de tipo unaria y corresponde a que el destino se guarde el valor de una variable, número, booleano o string, ejemplos:
DEFINE $_B
DP $_B ASIG  10
  
3)para la suma, esta dada por el simbolo +, es de tipo binaria y corresponde a que el destino guarde el resultado de la suma de los operandos. NO SOPORTA de tio booleano. y cuando se opera un string con un entero, este ultimo se concadena al string. Ejemplos:

DEFINE $_A
DP $_A ASIG 5
DEFINE $_B
DP $_B ASIG  10
DEFINE $_Resultado
DP $_Resultado + $_A $_B 
DEFINE $_S 
DP $_S ASIG #numero nueve = #
DP $_S + $_S + 9
DEFINE $_Nombre
DP $_Nombre ASIG #Juan#
DEFINE $_Saludo
DP $_Saludo + #Hola, # $_Nombre  


4)Multiplicacion esta dada por el simbolo *, es de tipo binaria y corresponde a que el destino guarde el resultado de la multiplizacion de los operandos. No soporte de tipo booleano ni string. ejemplos:
DEFINE $_Largo
DEFINE $_Ancho
DEFINE $_Area
DEFINE $_Texto
DP $_Largo ASIG 6
DP $_Ancho ASIG 5
DP $_Area * $_Largo $_Ancho

5) mayor que, esta dado por el simbolo >, es de tipo binaria y corresponde a que el destino guarde el resultado de la operacion mayor que de los operadores (True o False). Solo es soportado por el tipo entero y el resultado es de tipo booleano. Ejemplos:

DEFINE $_NumeroUno
DEFINE $_NumeroDos
DP $_NumeroUno ASIG 670
DP $_NumeroDos ASIG 670
DEFINE $_Cond
DP $_Cond > $_NumeroUno $_NumeroDos

6) igual que, esta dado por el simbolo ==, es de tipo binaria y corresponde a que el destino guarde el resultado de la operacion igual que de los operandos (True o False), Es soportada por el tipo entero y tipo string. el resultado es de tipo booleano. Ejemplos:


DEFINE $_NumeroUno
DEFINE $_NumeroDos
DP $_NumeroUno ASIG 670
DP $_NumeroDos ASIG 670
DEFINE $_Cond
DP $_Cond == $_NumeroUno $_NumeroDos
DEFINE $_Var
DP $_Var #Hola# #HOLA#

AHORA: las condicionales del lenguaje está dado por la palabra if y else escrito de la siguiente forma:

if(condicion){
  codigo
} else {
  codigo
}

La condicion esta dada por una variable que debe contener True o False.
La cantidad de condicionales anidadas es hasta 3 veces.

if true:
    if true:
        if true:
            if true:  #Ultimo if posible a anidar, otro mas adentro y se rompe por mala sintaxis
                # Código

AHORA: Salida de texto, el lenguaje contiene una funcion llamada MOSTRAR(variable) , en la que escribe el contenido de la variable, seguido por un salto de linea, en un archivo de texto output.txt, pero eso lo vemos despues, quiero que mi parser primero que nada asegure que la sintaxis del codigo.txt esté bien estructurado